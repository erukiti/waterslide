{"version":3,"sources":["../../src/setup/fsio.js"],"names":["path","require","mkdirp","fs","Fsio","constructor","cache","writeFile","filename","content","opts","Promise","resolve","reject","buf","Buffer","equals","dirname","sync","options","mode","flag","isRewritable","err","readFile","readFileSync","e","checkExists","stat","module","exports"],"mappings":"AAAA;;AAGA,MAAMA,OAAOC,QAAQ,MAAR,CAAb;AACA,MAAMC,SAASD,QAAQ,QAAR,CAAf;AACA,MAAME,KAAKF,QAAQ,IAAR,CAAX;;AAOA,MAAMG,IAAN,CAAW;;AAGPC,kBAAc;AACV,aAAKC,KAAL,GAAa,EAAb;AACH;;AAEDC,cAAUC,QAAV,EAA4BC,OAA5B,EAAsDC,OAAmB,EAAzE,EAA6E;AACzE,eAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,gBAAIC,GAAJ;AACA,gBAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiC;AAC7BK,sBAAM,IAAIC,MAAJ,CAAWN,OAAX,CAAN;AACH,aAFD,MAEO;AACHK,sBAAML,OAAN;AACH;;AAED,gBAAI,KAAKH,KAAL,CAAWE,QAAX,KAAwB,KAAKF,KAAL,CAAWE,QAAX,EAAqBQ,MAArB,CAA4BF,GAA5B,CAA5B,EAA8D;AAC1DF,wBAAQ,KAAR;AACA;AACH,aAHD,MAGO;AACH,qBAAKN,KAAL,CAAWE,QAAX,IAAuBM,GAAvB;AACH;;AAED,gBAAId,KAAKiB,OAAL,CAAaT,QAAb,MAA2B,GAA/B,EAAoC;AAChCN,uBAAOgB,IAAP,CAAYlB,KAAKiB,OAAL,CAAaT,QAAb,CAAZ;AACH;;AAED,kBAAMW,UAAU,EAAhB;AACA,gBAAIT,KAAKU,IAAT,EAAe;AACXD,wBAAQC,IAAR,GAAeV,KAAKU,IAApB;AACH;AACDD,oBAAQE,IAAR,GAAeX,KAAKY,YAAL,GAAoB,GAApB,GAA0B,IAAzC;;AAEAnB,eAAGI,SAAH,CAAaC,QAAb,EAAuBM,GAAvB,EAA4BK,OAA5B,EAAqCI,OAAO;AACxC,oBAAIA,GAAJ,EAAS;AACLV,2BAAOU,GAAP;AACH,iBAFD,MAEO;AACHX,4BAAQ,IAAR;AACH;AACJ,aAND;AAOH,SAhCM,CAAP;AAiCH;;AAEDY,aAAShB,QAAT,EAA2B;AACvB,eAAO,IAAIG,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCV,eAAGqB,QAAH,CAAYhB,QAAZ,EAAsB,CAACe,GAAD,EAAMd,OAAN,KAAkB;AACpC,oBAAIc,GAAJ,EAAS;AACLV,2BAAOU,GAAP;AACH,iBAFD,MAEO;AACH,yBAAKjB,KAAL,CAAWE,QAAX,IAAuBC,OAAvB;AACAG,4BAAQH,OAAR;AACH;AACJ,aAPD;AAQH,SATM,CAAP;AAUH;;AAEDgB,iBAAajB,QAAb,EAA+B;AAC3B,YAAI;AACA,kBAAMC,UAAUN,GAAGsB,YAAH,CAAgBjB,QAAhB,CAAhB;AACA,iBAAKF,KAAL,CAAWE,QAAX,IAAuBC,OAAvB;AACA,mBAAOA,OAAP;AACH,SAJD,CAIE,OAAOiB,CAAP,EAAU;AACR,mBAAO,IAAP;AACH;AACJ;;AAEDC,gBAAYnB,QAAZ,EAA8B;AAC1B,eAAO,IAAIG,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCV,eAAGyB,IAAH,CAAQpB,QAAR,EAAkB,CAACe,GAAD,EAAMK,IAAN,KAAe;AAC7B,oBAAIL,GAAJ,EAAS;AACLX,4BAAQ,KAAR;AACH,iBAFD,MAEO;AACHA,4BAAQ,IAAR;AACH;AACJ,aAND;AAOH,SARM,CAAP;AASH;AA5EM;;AA+EXiB,OAAOC,OAAP,GAAiB1B,IAAjB","file":"fsio.js","sourcesContent":["'use strict'\n// @flow\n\nconst path = require('path')\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\n\nexport type FsioOption = {\n    mode?: number,\n    isRewritable?: boolean\n}\n\nclass Fsio {\n    cache: {[string]: Buffer}\n\n    constructor() {\n        this.cache = {}\n    }\n\n    writeFile(filename: string, content: string | Buffer, opts: FsioOption = {}) {\n        return new Promise((resolve, reject) => {\n            let buf\n            if (typeof content === 'string') {\n                buf = new Buffer(content)\n            } else {\n                buf = content\n            }\n\n            if (this.cache[filename] && this.cache[filename].equals(buf)) {\n                resolve(false)\n                return\n            } else {\n                this.cache[filename] = buf\n            }\n\n            if (path.dirname(filename) !== '.') {\n                mkdirp.sync(path.dirname(filename))\n            }\n\n            const options = {}\n            if (opts.mode) {\n                options.mode = opts.mode\n            }\n            options.flag = opts.isRewritable ? 'w' : 'wx'\n\n            fs.writeFile(filename, buf, options, err => {\n                if (err) {\n                    reject(err)\n                } else {\n                    resolve(true)\n                }\n            })\n        })\n    }\n\n    readFile(filename: string) {\n        return new Promise((resolve, reject) => {\n            fs.readFile(filename, (err, content) => {\n                if (err) {\n                    reject(err)\n                } else {\n                    this.cache[filename] = content\n                    resolve(content)\n                }\n            })\n        })\n    }\n\n    readFileSync(filename: string) {\n        try {\n            const content = fs.readFileSync(filename)\n            this.cache[filename] = content\n            return content\n        } catch (e) {\n            return null\n        }\n    }\n\n    checkExists(filename: string) {\n        return new Promise((resolve, reject) => {\n            fs.stat(filename, (err, stat) => {\n                if (err) {\n                    resolve(false)\n                } else {\n                    resolve(true)\n                }\n            })\n        })\n    }\n}\n\nmodule.exports = Fsio\n"]}